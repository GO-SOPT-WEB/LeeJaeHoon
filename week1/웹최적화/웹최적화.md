## 🌐웹 최적화는 무엇일까?

**최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력을 의미합니다.**

웹은 무수히 많은 프로토콜과 많은 실행 환경 속에서 동작이 되고 있기 때문에 웹 성능 최적화 위한 방법들을 단순히 정의하는게 쉽지 않습니다. 웹 어플리케이션은 복합적인 환경에 따라 다르게 동작하고 같은 데이터를 사용해도 요청, 응답시간이 다를 수도 있습니다. 또 사용자가 인지적으로 느끼는 성능 향상은 상당히 주관적이며 지표 상으로 구체적인 성능 향상을 보여도 사용자는 인지 하지 못할 수도 있습니다.

그럼에도 불구하고 최적화를 해야하는 이유는 무엇일까요?

## 🌐최적화가 필요한 이유는 무엇일까?

사용자 경험 전문가 제이콥 닐슨은 웹페이지의 반응 시간이 되도록 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다고 분석했습니다. 그 이상 걸리면 컴퓨터 동작에 이상이 생겼다고 생각해 **결국 웹 페이지를 떠나고 사용자 경험에 부정적인 영향을 미치게 됩니다.** 이처럼 웹페이지의 반응 시간, 응답 속도는 웹 서비스의 경쟁력 가운데 하나이기 때문에 최적화는 꼭 필요한 과정입니다.

추가로 하나 재밌는 연구결과가 있는데 보시면 좋을 것 같아요

웹 사이트의 반응시간

-   **0.1초** : 사용자 동작에 해당 기능이 바로 반응한다고 느까는 시간
-   **1초** : 불필요하게 오래 기다리지는 않았다고 생각하는 시간 (컴퓨터의 일반적인 동작시간이라고 생각한답니다)
-   **10초** : 사용자가 집중력을 잃지 않는 최대시간 (저도 사실 로딩이 오래걸리면 10초를 세고 들어가지지 않는다면 웹페이지를 껐던 경험이 있습니다.)

## 🌐이를 위해 어떤 개발을 해야 할까?

웹 개발자는 성능 개선에 주의를 기울여야 하며 최소한의 데이터로 가장 빠른 시간에 사용자가 불편함을 느끼지 않는 최적의 화면을 띄어야합니다.

그러므로 웹 개발자는 **최소한의 데이터**로 **가장 빠른 시간**에 **사용자가 불편을 느끼지 않는 최적의 화면**을 띄워야합니다.

최적화 방법은 크게 세가지로 나눠볼 수 있는데 UI/UX 관련 최적화인 **프론트엔드 최적화**, 웹 서버, 데이터베이스, DNS서버등을 최적화하는 **백엔드 최적화** 통신 과정을 더 빠르게 해서 최적화하는 **프로토콜 최적화** 가 **있습니다**

그 중에서도 프론트엔드에서 최적화할 수 있는 방법을 알아보겠습니다.

## 프론트엔드 최적화

### 🌱로드시 블로킹 방지하기 (script 태그를 하단, css는 상단에 배치)

script 로드를 위한 script 태그는 DOM 생성 블로킹을 일으킬 수 있기 때문에 HTML 최하단에 배치 되어야 하며 비동기적인 로드를 위해서 **`async`** **`defer`**속성 사용도 고려 할 수 있습니다.

→ **`async`**와 **`defer`**속성은 스크립트 파일을 병렬로 다운로드하게 해줍니다. 즉 **로딩시 웹페이지 해석을 멈추지 않고** 스크립트를 다운로드 하는것입니다.

-   **`async`**: 다운로드 후 즉시 실행
-   **`defer`:** 웹페이지가 모두 그려지고 DOM이 들어왔을 때 스크립트 실행

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b82a8fe7-9406-4769-bb62-ba8d2f332100/Untitled.png)

출처 : [https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html](https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html)

정리하자면

```jsx
<script>  : 반드시 순서대로 실행되어야 할 때
<script async> : 빨리 실행되어야 할 때
<script defer> : 마지막에 파싱해도 아무런 영향이 없을 때
```

### 🌱CSS 상단배치 (head)

웹 페이지가 로드되면 html과 css가 동시에 파싱됩니다. html과 css는 바로 눈에 보이는 시각적 부분을 구현하기 때문에 빠르게 그려질 수록 좋으므로 **head에서 임포트합니다**

### 🌱media 속성 사용

media 속성을 활용하면 조건별로 css를 불러올 수 있으며 반응형 웹 제작시 유리합니다

media 속성이 없는 스타일시트는 해당 스타일시트를 브라우저가 해석하는 동안 화면에 스타일을 불러오지 않습니다.

```jsx
<link href="style.css" rel="stylesheet"> <!-- 🔺 -->
<link href="style.css" rel="stylesheet" media="(min-width:320px) and (max-width:768px)"> <!-- 브라우저의 넓이가 320이상 769미만일때 스타일시트 해석 -->
<link href="style.css" rel="stylesheet" media="print"> <!-- 프린트할때만 스타일시트 해석 -->
```

### 🌱img 지연로딩 활용하기

`loading` 속성을 사용해서 이미지를 브라우저 화면에 지연/병렬 로딩할 수 있습니다. 사용가능한 값으로는 auto, lazy, eagar가 있습니다.

-   auto : 디폴트 값, loading 속성을 쓰지 않는 것과 같음.
-   lazy : 화상에 보이는 부분만 먼저 출력하고 화면 밖 이미지는 로딩하지 않음
-   eagar : 화면 위치에 상관없이 페이지가 로딩되자마자 이미지 로딩

```jsx
<img src="cake.jpg" loading="lazy" alt="케이크이미지">
```

### 🌱**웹팩(Webpack) 사용**

모듈 번들러 Webpack을 사용하여 css와 js파일을 번들링해 리소스 요청을 줄일 수 있습니다.

`번들링` : 번들링이란 모듈들의 의존성 관계를 파악하여 그룹화시켜주는 작업을 뜻합니다. 모듈(module)이란 분리된 파일이므로 분리된 녀석들을 하나로 합쳐주는 과정을 말합니다.

### 🌱간결한 스타일 작성

복잡한 css selector는 지양해야합니다. css가 방대할 수록 레이아웃을 그리는 데에 시간이 많이 소요되므로 선택자를 간결하게 사용하여 특이성을 낮게 유지하는 것이 좋습니다. 또한 중복해서 사용되는 css속성들은 전체에 한번에 적용하여 중복을 줄이도록 하는 것이 좋습니다.

```jsx
section .sectionWrapper {...} --- x
.sectionWrapper {...} --- o

```

### 🌱복잡한 DOM트리 지양

DOM 트리가 커질 수록 DOM 변경 시 계산해야 하는 것이 많아집니다 따라서

불필요하게 감싼 요소를 제거하고 깊이를 얕게 하는 것을 지향해야 합니다.

### 🌱**리플로우, 리페인트(Reflow/Repaint)를 고려한 스타일 작성**

**브라우저의 스타일이 그려지는 순서.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc42da47-c530-4161-b2be-5dc6f9b5448a/Untitled.png)

**브라우저 렌더링 과정**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad23438e-d1b2-40b9-bd32-14fbf51f22b3/Untitled.png)

**리플로우 :** 레이아웃의 넓이, 높이, 위치 등에 영향을 주는 css 속성을 변경할 경우 'Layout'부터 다시 그려지는 과정

**리페인트** : 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것.

레이아웃에 영향을 주지 않는 속성을 변경하면 레이아웃을 건너뛰고 페인트 작업부터 수행

**클래스 변화에 따른 변경 시, 최대한 DOM 구조 상 끝단에 위치한 노드에 주어야합니다.**

가급전 말단에 위치한 노드 수치 변경시 리플로우 수행반경을 전체에서 일부로 둘 수 있음

**애니메이션이 들어간 노드는 가급적 `position:fixed` 나 `position:absolute` 로 지정하여 전체 노드에서 분리시킵니다.**

전체 노드에 걸쳐 리플로우 비용이 들지 않으며 해당 노드에 리페인트 비용만 들어가게 됩니다.

### 🌱CDN사용

CDN(Content Delivery Network)는 유저에게 많은 콘텐츠를 손실없이 빠르게 전달하는 서비스입니다.

대용량 콘텐츠 다운 또는 스트리밍에 사용합니다.

! 사용한 만큼 비용 지불

## 🌐최적화를 위한 개발을 꼭 해야 할까?

최적화는 곧 사용자 경험을 의미합니다. 위에서 말했듯이 빠른 로딩 시간은 사이트 내에 신뢰를 만들고 더 많은 재 방문자를 만들어주며 타 사이트에 비해 더 많은 사용자들의 선택을 얻을 수 있습니다. 따라서 이는 전환율이나 지속적인 사용에도 밀접하게 연관이 있고 나아가서는 매출에도 영향을 미칩니다.

예를 들어 핀터레스트는 페이지 로드 시간을 40% 감소시켜서 검색엔진을 통해 유입된 트래픽 및 가입자 전환율이 15%나 증가하는 결과를 얻었고, 이와 반대로 BBC는 사이트가 로딩하는 데 걸리는 매 초마다 10%의 사용자들이 감소하기도 했습니다. 또한 로딩 속도 1초가 빨라지면 아마존 판매량의 1%, 구글 검색량의 0.2%, 월마트의 전환율이 2%가 증가한다고 하는데 숫자는 작아 보여도 금액으로 환산하면 수억에서 수십억 달러에 달한다고 하니 절대 무시할 수 없는 비율입니다.

이와 같은 예시는 정말 빙산의 일각일 뿐이고 연구결과로 증명된 최적화와 사용자 경험의 관련성, 그리고 그로인한 긍정적, 부정적 효과는 굉장히 많이 찾아볼 수 있습니다.

최적화는 좋은 사용자경험을 충족시키기 위한 최선의 방법이므로 개발자들은 최적화에 신경쓰는 습관을 길러야할 것입니다.

Reference :

[https://webclub.tistory.com/346](https://webclub.tistory.com/346)

[https://velog.io/@hsecode/최적화-웹-성능-최적화-방법-5분-완성](https://velog.io/@hsecode/%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-5%EB%B6%84-%EC%99%84%EC%84%B1)

[https://velog.io/@zaman17/기술면접대비-브라우저-렌더링-순서와-원리](https://velog.io/@zaman17/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%88%9C%EC%84%9C%EC%99%80-%EC%9B%90%EB%A6%AC)

[https://fe-developers.kakaoent.com/2022/220120-ux-and-perf-in-kakaowebtoon/](https://fe-developers.kakaoent.com/2022/220120-ux-and-perf-in-kakaowebtoon/)

[https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS1068777819&cate_cd=](https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS1068777819&cate_cd=)
